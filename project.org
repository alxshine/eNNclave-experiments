* NN SGX
In order to perform inference with a given machine learning model, the weights and architecture must be known.
Allowing a third party to query a model, while keeping it secret, requires providing the model as an online oracle to them.
While this allows keeping the model parameters private and thus continuing to monetize the model queries, it requires providing the infrastructure and computational power required to perform the inferences.

Our goal is to leverage the data confidentiality that Trusted Execution Environments (TEEs) promise to turn these online oracles into offline oracles, freeing the model creator from having to provide the infrastructure required for inference.
While the model creator benefits from the model parameters staying private, the model user can now also keep their inference data private, as they no longer have to provide them to the model creator for their inference.
Thus all involved parties gain privacy from such a model.

We provide a proof of concept implementation for certain Tensorflow operations, and provide a mechanism to cut the last \($n$\) layers and run them inside an Intel SGX enclave.
We then evaluated the performance impact of different cuts for four different neural net models.
This gives us an approximation for the impact caused by moving parts of the model to the CPU, and the additional impact introduced by the overhead of TEE execution.

*** TODO Actual values still to come

** Introduction

*** TODO Fix terminology (provider, customer, model, etc.)

Training a machine learning model requires large amounts of data, domain knowledge, and significant computation power.
Organizations wishing to use the predictive powers of these models often lack the knowledge and hardware required to train these models, and outsource parts of the task using Machine Learning as a Service (MLaaS) providers, who provide automated tools to generate ML models for certain types of tasks.

MLaaS providers usually monetize their models per query or per time frame.
Both strategies require them to keep the model parameters - and to some extent the architecture - secret.
A common strategy is to offer access to the finished model only as an online oracle which customers can query with their data, and which responds with the inference result.
Providing such an oracle requires the provider to continually reserve the needed computational power required for inference on the customer's model.
It also requires the customer to keep sending data to the provider at inference time, which can be undesirable and potentially illegal depending on the domain.
As such, the online oracle model required for continuous monetization is undesirable for both provider and customer.

*** TODO Try to find a MLaaS provider where you "buy" the finished model

Our approach transforms the online oracle into an offline oracle by leveraging the data confidentiality promised by trusted execution environments (TEEs).
We provide a (naive) implementation of different Tensorflow (TF) operations in C, as well as a tool to automatically generate the calls to these operations from an existing TF model.
Our tool also extracts the weights from the model and makes them usable and protecting them inside the enclave.
We also provide an enclave wrapper which integrates seamlessly into TF, making our enclave models drop-in replacements for regular TF models.

*** DONE Find out if our code is actually encrypted, and if the weights are secure
    CLOSED: [2020-02-12 Wed 13:25]

While this approach still requires customers to share their training data with MLaaS providers, it allows us to leverage the higher performance of GPUs and optimized implementations of TF operators during training.
Training a full model inside the enclave in order to provide data confidentiality during training time has been done \(\cite{ohrimenko16enclave}\), but was not the goal for our research.
As evidenced by Section [[sec:results][Results]] the performance impact of running a model inside the enclave can be quite large, especially for large convolutional neural nets (CNNs) as are commonly used in current image recognition tasks.
While these performance impacts could be acceptable during inference, depending on the application scenario, they seem to us be prohibitive during training, which caused us to use regular TF on the GPU for training.

The rest of this paper is organized as follows:
Section [[sec:background][Background]] gives some background on the computations required for inference, as well as on TEEs in general, and Intel SGX in particular.
Section [[sec:related][Related Work]] summarizes work we found that either covers model privacy, machine learning in TEEs, as well as attacks on data privacy.
Section [[sec:implementation][Implementation]] gives an overview of what we built and the general flow from the original TF model to a model running partly inside a TEE.
Section [[sec:setup][Experimental Setup]] details the models, hardware, measurements we used for evaluation.
The results of our experiments are then shown and evaluated in Section [[sec:results][Experiment Results]].
We offer a discussion of our results and in Section [[sec:discussion][Discussion]], and a conclusion together with what we see as valuable future work in Section [[sec:conclusion][Conclusion]].

** Background
<<sec:background>>

This section is meant to illustrate the mathematical operations that happen during the forward pass of a neural net, as well as the higher level processes when executing code inside a TEE.

*** Neural Net Math

*** Trusted Execution environments

*** Intel SGX
**** TODO Look into signing process of Intel SGX

** Related Work
<<sec:related>>
We have different areas of related work that are relevant to this project.
The most directly relevant area is model stealing attacks and adversarial robustness.
In model stealing an attacker tries to build a replicant model that rivals the prediction accuracy of the stolen model, with hopefully lower cost than using the original model.
[[file:related_work/tramer16stealing.pdf][Tramer et al.]] use a model-dependent dataset augmentation algorithm to find a reasonably low number of queries required for extracting the model.
The number they arrive at for NNs is ~100*k~, where ~k~ is the number of parameters.
Our model (even with the weights in the feature extractor fixed) still have ~18,000,000 trainable parameters, which pushes this attack (as it is) outside the realm of feasability in my opinion.

Another relevant area of research is adversarial attacks.
[[file:related_work/papernot17practical.pdf][Papernot et al.]] have presented a so-called black-box transfer attack, in which an attacker builds a local replicant model and builds adversarial examples on the gradients of that model.
This requires far less queries than are required for model stealing, but the replicant model does not have to be accurace.
Its only requirement is that its gradients are sufficiently aligned with the target model to build functional adversarial examples.

Our implementation affects data privacy, as it allows users to keep the data they wish to predict on private.
It also allows for the creation of offline black box oracles, which are used e.g. in [[file:related_work/shokri17membership.pdf][set membership attacks]].
As it currently stands, we do not return confidence values, only the resulting label.
This makes the attack presented by Shokri et al. not better than chance, as evidenced by their own results.

In the context of data privacy [[file:related_work/ohrimenko16enclave.pdf][Ohrimenko et al.]] have also previously combined machine learning with trusted enclaves.
The difference between their approach and ours is that they trained the model inside the enclave, which allows parties to also keep their training data private.
Their focus is on ensuring that no inference on the training data can be made using timing side channels, and they disregard performance.
Our focus is instead on the performance impact of such an approach.

[[file:related_work/tramer19slalom.pdf][Tramer et al.]] provide a mechanism to use the enclave as a controller for running NNs on the GPU.
Every layer is verified inside the Enclave, to give a statistical guarantee for integrity.
They also utilize an additive stream cipher which is (as they claim, I don't know enough of the math behind it to verify) invariant to the computations taking place in the DNN.
This gives them data privacy, while running the model on the provider's hardware.

The enclave alone does not provide a mechanism for rate limiting, and thus not for monetization.
[[file:related_work/kaptchuk2019state.pdf][Kaptchuk et al.]] utilize signatures coming from a server for this.
Their main contribution is putting the signatures in a public ledger, which might be sexy, but not necessary for our use-case.
The basic idea is very relevant however.
By having a customer send a hash of the data they wish to run inference on to the provider, who then signs the hash (after being paid) and sends the signature back, we can monetize access to the model by query.
The model can then verify the signature using the public testing key of the provider.
Only if the signature is valid will it run inference.

** Implementation
<<sec:implementation>>

** Experimental Setup
<<sec:setup>>

Image recognition tasks as well as text classification tasks are used for testing.
The image recognition tasks are MNIST using a small CNN, and MIT67 using a pretrained VGG16 network as feature extractor.
I fixed the weights for the VGG16 feature extractor during training of the final classification 
For the text classfication we used IMDB review sentiment classification using MLPs, and Rotten Tomatoes review sentiment classification using CNNs on sequences.
The code for these is taken from [[https://github.com/google/eng-edu/tree/master/ml/guides/text_classification][here]].
This choice of datasets gives us reasonably large CNNs for multiple tasks and media types, as well as smaller models for a task of both kinds.

The links for the datasets are as follows:
- [[http://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz][IMDB sentiment analysis]]
- [[https://www.kaggle.com/c/3810/download/train.tsv.zip][Rotten Tomatoes sentiment analysis]]
- MNIST is taken from [[https://blog.tensorflow.org/2019/02/introducing-tensorflow-datasets.html][tensorflow_datasets]]
- [[https://web.mit.edu/torralba/www/indoor.html][MIT67 Indoor scene recognition]]

** Experiment Results
<<sec:results>>

We do have some results

*** Retraining performance
I did some experiments with fine tuning and freezing.
Unfreezing the weights in the feature extractor during initial training is detrimental to performance, detroying any benefit that would be gained from using a pretrained feature extractor.
However, training the fully connected layers for 500 epochs, unfreezing the weights in the feature extractor, and then training the whole model with a reduced learning rate yields an accuracy increase.
In my tests I fine-tuned the weights using a stochastic gradient descent optimizer for 2000 epochs, once with fixed VGG weights and once while retraining the VGG weights as well.
Starting accuracy for both variants was 53.507%.
Fine-tuning with VGG weights fixed plateaued at roughly 57.5%, while fine-tuning all weights reached an accuracy of 64.5%.

This might be because the feature extractor has been trained on a general purpose dataset and is now being used on a specific scene recognition dataset.
[[file:related_work/Zhou%20et%20al_2014_Learning%20Deep%20Features%20for%20Scene%20Recognition%20using%20Places%20Database.pdf][Zhou et al.]] have studied this problem and provide a different set of weights for the VGG feature extractor specific for scene recognition.
I will try these weights in the future, but they have to be transformed from Caffe to TensorFlow.

** Discussion
<<sec:discussion>>

** Conclusion
<<sec:conclusion>>

* Old Stuff
** Current Status
The technical part of this research project is mostly done, and only few cleanup jobs remain.
My current focus will be on the writeup, and finding a clear narrative for my reasoning.

*** Enclave Implementation
Implementing all TF operations present in the used models is finished.
The results are (mostly) consistent with the original TF models, which indicates a correct implementation and thus meaningful timing measurements.
The few different results are most likely due to rounding differences on different hardware platforms, and algorithmic choices (different order of operations).
Please note that differences do not necessarily mean errors.
We have observed cases where the original result was a misclassification, but the enclave variant was not.

**** TODO Rigorously measure and classify label differences between TF, native and enclave

*** Model Training
As I lack the required expertise in the area of neural net design, I tried to use existing models where I could.
The model for MNIST is taken from [[https://keras.io/examples/mnist_cnn/][this Keras example]].
I could not find an architecture using VGG16 as a feature extractor, and for some reason (probably due to a bug somewhere) using any version of ResNet does not yield better results than random choice.
This is true for any model using a [[https://www.tensorflow.org/api_docs/python/tf/keras/layers/BatchNormalization?version=stable][BatchNormalization layer]], which lead me to the conclusion that this is an implementation error.
Due to this I trained a model using VGG16 as a feature extractor until it gave reasonably good results (between 55% and 60% validation accuracy for 67 classes).
Both models for text classification are taken from [[https://github.com/google/eng-edu/tree/master/ml/guides/text_classification][this]] machine learning tutorial by Google.
For our tests the models do not have to perform close to the state of the art, only well enough that we can rule out the possibility of trivial weights with confidence, as these could impact our performance measurements in unforeseen ways.

** Timing measurements
All code is compiled for SGX in HW_PRERERELEASE mode

*** First Attempt
**** Rotten Tomatoes
 The times are averaged over 50 batches.
 Enclave setup is not included in the times.
 The first run is discarded to also filter out TF-GPU setup time.

 A summary of the model is as follows:
 #+BEGIN_SRC text
 embedding:               	(None, 49, 200)
 dropout:                 	(None, 49, 200)
 separable_conv1d:        	(None, 49, 64)
 separable_conv1d_1:      	(None, 49, 64)
 max_pooling1d:           	(None, 16, 64)
 separable_conv1d_2:      	(None, 16, 128)
 separable_conv1d_3:      	(None, 16, 128)
 global_average_pooling1d:	(None, 128)
 dropout_1:               	(None, 128)
 dense:                   	(None, 5)
 #+END_SRC

 The column specifies the number of layers *from the back* that are put in the enclave.

***** Tensorflow-GPU Times

 #+PLOT: ind:1 deps:(2 3 4 5 6 7 8 9)
 |-----------------+----------+----------+----------+----------+----------+----------+----------+----------|
 | #(Batch)\Layers |        1 |        2 |        3 |        4 |        5 |        6 |        7 |        8 |
 |-----------------+----------+----------+----------+----------+----------+----------+----------+----------|
 |               1 | 0.021391 | 0.021506 | 0.021263 | 0.021504 | 0.021386 | 0.022156 | 0.022420 | 0.021786 |
 |               5 | 0.021275 | 0.021364 | 0.021191 | 0.022280 | 0.021514 | 0.022063 | 0.020909 | 0.021172 |
 |              10 | 0.021836 | 0.021329 | 0.021640 | 0.021221 | 0.021072 | 0.021168 | 0.021441 | 0.021476 |
 |              50 | 0.010124 | 0.028781 | 0.030833 | 0.026013 | 0.025481 | 0.025112 | 0.024917 | 0.025178 |
 |             100 | 0.043587 | 0.044060 | 0.045346 | 0.031918 | 0.031637 | 0.031476 | 0.031207 | 0.031222 |
 |             500 | 0.110506 | 0.107064 | 0.101755 | 0.066747 | 0.069347 | 0.069550 | 0.068083 | 0.071315 |
 |            1000 | 0.188149 | 0.199242 | 0.205119 | 0.153562 | 0.148908 | 0.150407 | 0.140155 | 0.138775 |
 |            5000 | 1.206407 | 1.155464 | 1.180732 | 1.104479 | 1.016594 | 1.103854 | 1.065218 | 0.997463 |
 |            7500 | 1.739533 | 1.722203 | 1.664009 | 1.713971 | 1.647305 | 1.559547 | 1.509747 | 1.509626 |
 |           10000 | 2.001191 | 2.371181 | 2.288010 | 2.167776 | 2.171341 | 2.158835 | 2.139454 | 2.277547 |
 |-----------------+----------+----------+----------+----------+----------+----------+----------+----------|

***** Enclave Times

 #+PLOT: ind:1 deps:(2 3 4 5 6 7 8 9)
 |-----------------+----------+----------+----------+-----------+-----------+-----------+-----------+------------|
 | #(Batch)\Layers |        1 |        2 |        3 |         4 |         5 |         6 |         7 |          8 |
 |-----------------+----------+----------+----------+-----------+-----------+-----------+-----------+------------|
 |               1 | 0.004030 | 0.004101 | 0.003948 |  0.007372 |  0.008193 |  0.008101 |  0.010586 |   0.017241 |
 |               5 | 0.004136 | 0.004141 | 0.004123 |  0.021474 |  0.025296 |  0.025948 |  0.035261 |   0.066643 |
 |              10 | 0.004520 | 0.004509 | 0.004479 |  0.036173 |  0.045170 |  0.045452 |  0.065724 |   0.128432 |
 |              50 | 0.032096 | 0.009325 | 0.010035 |  0.164765 |  0.208798 |  0.208383 |  0.307739 |   0.627604 |
 |             100 | 0.018667 | 0.018899 | 0.021223 |  0.329236 |  0.415729 |  0.415255 |  0.614807 |   1.247830 |
 |             500 | 0.158167 | 0.139720 | 0.154573 |  1.600334 |  2.074725 |  2.083692 |  3.058047 |   6.303066 |
 |            1000 | 0.336998 | 0.339511 | 0.370344 |  3.205655 |  4.156700 |  4.118088 |  6.186466 |  12.533901 |
 |            5000 | 1.822304 | 1.638312 | 1.880398 | 15.906983 | 20.669846 | 20.409218 | 30.551559 |  62.745630 |
 |            7500 | 2.547575 | 2.434002 | 2.648802 | 23.779323 | 30.571529 | 30.915689 | 46.082133 |  93.974223 |
 |           10000 | 2.731499 | 3.396491 | 3.452197 | 31.899413 | 41.893637 | 41.231440 | 61.369204 | 124.449159 |
 |-----------------+----------+----------+----------+-----------+-----------+-----------+-----------+------------|


**** MIT67
 The times are averaged over 50 batches.
 Enclave setup is not included in the times.
 The first run is discarded to also filter out TF-GPU setup time.

 A summary of the model is as follows:
 #+BEGIN_SRC text
 input_1:                 	[(None, 224, 224, 3)]
 block1_conv1:            	(None, 224, 224, 64)
 block1_conv2:            	(None, 224, 224, 64)
 block1_pool:             	(None, 112, 112, 64)
 block2_conv1:            	(None, 112, 112, 128)
 block2_conv2:            	(None, 112, 112, 128)
 block2_pool:             	(None, 56, 56, 128)
 block3_conv1:            	(None, 56, 56, 256)
 block3_conv2:            	(None, 56, 56, 256)
 block3_conv3:            	(None, 56, 56, 256)
 block3_pool:             	(None, 28, 28, 256)
 block4_conv1:            	(None, 28, 28, 512)
 block4_conv2:            	(None, 28, 28, 512)
 block4_conv3:            	(None, 28, 28, 512)
 block4_pool:             	(None, 14, 14, 512)
 block5_conv1:            	(None, 14, 14, 512)
 block5_conv2:            	(None, 14, 14, 512)
 block5_conv3:            	(None, 14, 14, 512)
 block5_pool:             	(None, 7, 7, 512)
 global_average_pooling2d:	(None, 512)
 dense:                   	(None, 2048)
 dropout:                 	(None, 2048)
 dense_1:                 	(None, 2048)
 dropout_1:               	(None, 2048)
 dense_2:                 	(None, 67)
 #+END_SRC

***** Tensorflow-GPU Times
 #+PLOT: ind 1 deps:(25)
 | #(Batch)\Layers |        1 |        3 |        5 |        7 |        8 |        9 |       10 |       15 |
 |-----------------+----------+----------+----------+----------+----------+----------+----------+----------|
 |               1 | 0.025428 | 0.036029 | 0.048565 | 0.059587 | 0.063313 | 0.069026 | 0.071457 | 0.091238 |
 |               2 |          |          |          |          |          |          |          |          |
 |               3 | 0.025450 | 0.037214 | 0.051288 | 0.064751 | 0.070158 | 0.072505 | 0.077171 | 0.089956 |
 |               4 |          |          |          |          |          |          |          |          |
 |               5 | 0.025279 | 0.038138 | 0.052808 | 0.064366 | 0.071037 | 0.074503 | 0.077482 | 0.089345 |
 |               6 |          |          |          |          |          |          |          |          |
 |               7 |          |          |          |          |          |          |          |          |
 |               8 |          |          |          |          |          |          |          |          |
 |               9 |          |          |          |          |          |          |          |          |
 |              10 | 0.026604 | 0.039616 | 0.052013 | 0.068981 | 0.076059 | 0.074010 | 0.080428 | 0.100843 |
 |              11 |          |          |          |          |          |          |          |          |
 |              12 |          |          |          |          |          |          |          |          |
 |              13 |          |          |          |          |          |          |          |          |
 |              14 | 0.032006 | 0.045735 | 0.057639 | 0.065905 | 0.074745 | 0.077882 | 0.078972 | 0.096764 |
 |              15 |          |          |          |          |          |          |          |          |
 |              16 |          |          |          |          |          |          |          |          |
 |              17 |          |          |          |          |          |          |          |          |
 |              18 | 0.030911 | 0.044314 | 0.056702 | 0.067821 | 0.070497 | 0.073752 | 0.078821 | 0.092224 |
 |              19 |          |          |          |          |          |          |          |          |
 |              20 |          |          |          |          |          |          |          |          |
 |              21 |          |          |          |          |          |          |          |          |
 |              22 | 0.033106 | 0.045210 | 0.059194 | 0.068355 | 0.073950 | 0.076135 | 0.081242 | 0.098309 |
 |              23 | 0.026676 | 0.040060 | 0.053027 | 0.068507 | 0.072139 | 0.075335 | 0.078200 | 0.092684 |
 |              24 | 0.028796 | 0.038081 | 0.055922 | 0.068730 | 0.074985 | 0.076803 | 0.079242 | 0.098056 |
 |-----------------+----------+----------+----------+----------+----------+----------+----------+----------|


***** Enclave Times
 The output of the first run was the following:
 #+BEGIN_SRC text
 BATCH SIZE:	1
 NUM BATCHES:	10
 SKIPPING FIRST 1 RESULTS

 Tensorflow times:
 [0.02612829 0.02624774 0.02640581 0.02641249 0.02847791 0.02616763
  0.02720594 0.0321269  0.03499079 0.03379607]
 Mean:	0.028796
 Min:	0.026128
 Max:	0.034991

 Enclave times:
 [96.11019945 96.03487802 96.06326938 96.08898449 96.09725094 96.05501556
  96.0578084  96.07562447 96.07399631 96.05862665]
 Mean:	96.071565
 Min:	96.034878
 Max:	96.110199

 Enclave is slower than TF by a factor of 3336.286531
 #+END_SRC

 Times for 1-5 layers in the enclave are averaged over 10 runs.
 Anything more is averaged over 5 runs.

 #+PLOT: ind:1 
 |-------------------+--------------+--------------+--------------+--------------+--------------+--------------+---------------+---------------|
 | Layers in Enclave | Batch Size 1 | Batch Size 3 | Batch Size 5 | Batch Size 7 | Batch Size 8 | Batch Size 9 | Batch Size 10 | Batch Size 15 |
 |-------------------+--------------+--------------+--------------+--------------+--------------+--------------+---------------+---------------|
 |                 1 |     0.008051 |     0.016898 |     0.026013 |     0.542857 |     0.038424 |     0.040877 |      0.044355 |      0.055704 |
 |                 2 |              |              |              |              |              |              |               |               |
 |                 3 |     0.099809 |     0.286546 |     0.470940 |     0.659233 |     0.742482 |     0.831228 |      0.926700 |      1.375040 |
 |                 4 |              |              |              |              |              |              |               |               |
 |                 5 |     0.110832 |     0.324257 |     0.533429 |     0.756050 |     0.858298 |     0.981950 |      1.049649 |      1.602558 |
 |                 6 |              |              |              |              |              |              |               |               |
 |                 7 |              |              |              |              |              |              |               |               |
 |                 8 |              |              |              |              |              |              |               |               |
 |                 9 |              |              |              |              |              |              |               |               |
 |                10 |     8.381979 |    25.063495 |    41.699738 |    58.579399 |    66.744637 |    75.042203 |     83.625200 |    125.360794 |
 |                11 |              |              |              |              |              |              |               |               |
 |                12 |              |              |              |              |              |              |               |               |
 |                13 |              |              |              |              |              |              |               |               |
 |                14 |    33.872001 |   101.557123 |   169.223098 |   236.851785 |   270.741908 |   304.748191 |    338.318888 |    507.579299 |
 |                15 |              |              |              |              |              |              |               |               |
 |                16 |              |              |              |              |              |              |               |               |
 |                17 |              |              |              |              |              |              |               |               |
 |                18 |    62.009544 |   185.945586 |   309.974662 |   437.712523 |   499.176943 |   561.607938 |    624.333441 |    934.449329 |
 |                19 |              |              |              |              |              |              |               |               |
 |                20 |              |              |              |              |              |              |               |               |
 |                21 |              |              |              |              |              |              |               |               |
 |                22 |    83.603271 |   250.719513 |   417.888367 |   585.269710 |   668.728308 |   752.435096 |    835.719889 |   1253.506332 |
 |                23 |    90.855354 |   270.726609 |   450.900166 |   628.823300 |   718.658031 |   808.565028 |    898.546926 |   1347.544501 |
 |                24 |    96.071565 |   288.826607 |   482.205610 |   669.602621 |   764.924860 |   860.603075 |    959.033667 |   1457.326541 |
 |-------------------+--------------+--------------+--------------+--------------+--------------+--------------+---------------+---------------|

*** Second Attempt
I remeasured the times with an automated script, averaging all times over 5 runs.
The script measures the time spent in Tensorflow, in native C, as well as the penalty incurred by executing on the enclave.
For the measurements the model is split into two parts: the enclave part, and the operations outside the enclave.
The output of the whole model can be viewed as a composition of the first and second part of the model, which allows me to test the results for consistency.
With this split, I can measure the distinct parts of the execution:
- enclave setup
- TF execution including setup
- native C execution
- enclave execution
- enclave teardown

Enclave setup, execution and teardown times are summed up and summarized as enclave time in the visualizations.
The enclave part of the network is actually run twice, once in native C and once on the enclave.
This allows me to separate the performance penalty incurred by my code and from moving to the CPU from the penalty incurred by executing inside the enclave.
We called the difference between the native C and enclave execution times *enclave penalty*.

**** MIT67
[[fig:cpu_times]] shows the measured times for executing TF on the CPU, and [[fig:gpu_times]] shows the times with TF running on GPU.
Beneath the x-axis are the layers of the model.
All layers to the right of a timing bar are run in native/enclave code, while all layers to the left are run using normal TF operations.
The rightmost bar is the time it takes to run the entire model in TF alone.

#+CAPTION: CPU execution times
#+NAME:   fig:cpu_times
[[./tex/images/graphic_cpu.png]]

#+CAPTION: GPU execution times
#+NAME:   fig:gpu_times
[[./tex/images/graphic_gpu.png]]

**** DONE Measure MNIST execution time
     CLOSED: [2020-01-14 Tue 13:27]

**** DONE Measure IMDB execution time
     CLOSED: [2020-01-14 Tue 14:51]

**** DONE Measure Rotten Tomatoes execution time
     CLOSED: [2020-01-14 Tue 13:30]

* README

** Setting up a testing environment
Building SGX enclaves on Linux requires building the SGX-SDK from scratch.
This process only works on Ubuntu 18.04 and some other older distributions.
Our test machines run Ubuntu Server 18.04, and I provide a setup script for the SDK [[file:setup/setup_sgx_machine.sh][here]].

The python requirements are all in [[file:requirements.txt][requirements.txt]].

** Training a model
Our current evaluation dataset, MIT67, can be downloaded [[http://web.mit.edu/torralba/www/indoor.html][here]].
The site provides a download of the dataset, as well as a specification of which images are in the training and test sets.
The specification files are great for having consistent and reproducible results.

Our training scripts expect the extracted data to be in ~data/mit67~, with both ~.txt~ files being in that directory as well.
The model can then be trained using the ~mit67_train.py~ script.

** Extracting the enclave
The script called ~build_enclave_files.py~ is used to generate the weight files and the C functions.
It takes two parameters: the original model file, and the number of layers to extract into an enclave.
The extracted layers will be replaced by an ~EnclaveLayer~, which wraps the generated enclave in a manner compatible with the TensorFlow API.
From the original layers that were not extracted and the new ~EnclaveLayer~ it builds a new model, and saves it.

The script creates a ~forward.cpp~ and multiple ~.bin~ files.
Inside the ~.bin~ files are the layer weights which will be compiled into the enclave.
The ~forward.cpp~ file contains the forward function of the enclave.

** Compiling the enclave
Building the enclave (or native) code happens in the ~lib~ directory, so move the generated files there.

The decision which version to build is decided based on the ~MODE~ environment variable.
All directories contain Makefiles, so running ~make~ in the project root will build all necessary subdirectories.

** Running the enclave
*** Setting up ~LD_LIBRARY_PATH~
The enclave model needs to be able to find the shared libraries that were previously compiled.
To provide the location of the libraries, please run this command from the project root:
#+BEGIN_SRC bash
source setup/setup_ld_path.sh
#+END_SRC

*** Evaluating models
TODO

** Under the hood
The underlying interaction with the enclave is a bit roundabout, but that also preserves modularity.

The ~EnclaveLayer~ calls the Python-C interoperability code in [[file:interop/pymatutilmodule.c][pymatutilmodule.c]] (which is previosly compiled into a shared library).
That code does the conversion between Python ~byte~ arrays and C ~char~ arrays.
It then calls the libraries generated in the ~lib~ directory, and converts the output back to Python objects.

The enclave also consists of two shared libraries, one in the enclave and one being the wrapper around the enclave that's autogenerated by the Intel SDK.

The rest is "basic" C interaction.
